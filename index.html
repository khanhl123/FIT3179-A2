<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>How Australians got to work?</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b1f3a;          /* dark blue page background */
      --card:#ffffff;
      --ink:#0f172a;
      --muted:#64748b;
      --border:#e5e7eb;
    }
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.6 Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    header{padding:28px 20px 8px;text-align:center;color:#e5ecff}
    h1{margin:0;font-size:clamp(32px,4vw,44px);letter-spacing:-.02em}
    .subtitle{margin-top:6px;color:#c8d3ff;font-size:14px;letter-spacing:.08em}
    .intro{max-width:900px;margin:12px auto 24px;color:#d9e2ff}
    .wrap{max-width:1200px;margin:0 auto;padding:0 16px 40px}
    .grid{display:grid;grid-template-columns:1fr;gap:20px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:10px;box-shadow:0 4px 18px rgba(15,23,42,.18)}
    .pad{padding:18px}
    .card h2{font-size:24px;margin:0 0 8px}
    .muted{color:var(--muted);font-size:14px}
    .legend{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
    .sw{width:14px;height:14px;border-radius:3px;border:1px solid #e2e8f0;display:inline-block}

    /* Greater Melbourne map */
    #mapBox{height:620px; position:relative;}
    .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:6px 0 10px}
    select,button,label{font:inherit}
    .btn{padding:6px 10px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;cursor:pointer}
    .btn.active{background:#0f172a;color:#fff;border-color:#0f172a}
    .tooltip{position:absolute;pointer-events:none;background:#111827;color:#fff;padding:8px 10px;border-radius:10px;font-size:12px;box-shadow:0 6px 18px rgba(0,0,0,.2)}
    .banner{margin-top:8px;color:#b45309;background:#fff7ed;border:1px solid #fde68a;padding:8px 10px;border-radius:8px;display:none}
    svg{display:block;width:100%;height:100%}
    .label{font-size:10px;fill:#111827;paint-order:stroke;stroke:#fff;stroke-width:3px;stroke-linejoin:round}
    @media (max-width: 960px){ .grid{grid-template-columns:1fr} #mapBox{height:520px} }
    #slopeChart{min-height:420px;}
    .vega-embed{background:#fff;border-radius:10px;}

    /* Two-column layout cards */
    .slope-grid{display:grid;grid-template-columns:minmax(320px,1fr) 360px;gap:16px;align-items:start}
    .map-grid{display:grid;gap:16px;align-items:start}
    .map-grid--notes-left{grid-template-columns:360px minmax(420px,1fr);}
    .side-notes{background:#f8fafc;border:1px solid #e2e8f0;border-radius:10px;padding:12px 14px;color:#334155;font-size:14px;line-height:1.48}
    .side-notes h3{margin:0 0 8px;font-size:16px;color:#0f172a}
    .side-notes p{margin:0 0 10px}
    @media (max-width: 900px){ .slope-grid,.map-grid{grid-template-columns:1fr} }

    /* Vega-Lite radio bindings style for the AUS map */
    #ausMap .vega-bindings{
      display:flex; gap:14px; align-items:center; margin-top:10px;
      padding:8px 10px; background:#f1f5f9; border:1px solid #e2e8f0; border-radius:10px; width:max-content;
      font-size:14px;
    }
    #ausMap .vega-bind-name{ font-weight:600; color:#0f172a; margin-right:4px; }
    #ausMap .vega-bindings label{ margin-right:10px; cursor:pointer; }
    #ausMap .vega-bindings input[type="radio"]{ transform:scale(1.1); accent-color:#0f172a; cursor:pointer; }

    /* Two-up layout for “Why the commute looks like this” */
    .two-grid{display:grid;grid-template-columns:minmax(320px,1fr) minmax(320px,1fr);gap:16px;align-items:start}
    @media (max-width: 900px){ .two-grid{grid-template-columns:1fr} }
    #cityLocalWork, #nationalCommuteTime{min-height:260px}
  </style>

  <!-- D3 + TopoJSON -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>

  <!-- Vega-Lite + Vega-Embed -->
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</head>
<body>
  <header>
    <h1>How Australians got to work?</h1>
    <div class="subtitle">AUSTRALIA-WIDE OVERVIEW (CAPITALS) • GREATER MELBOURNE DETAIL • 2016–2021</div>
    <p class="intro">
      Between 2016 and 2021 Australians shifted away from shared transport toward working from home and, when travel was needed, driving.
      The change was most pronounced in New South Wales and Victoria. Below we compare states in 2021 and then zoom into Greater Melbourne to see how local patterns changed.
    </p>
  </header>

  <div class="wrap">
    <div class="grid">

      <!-- ===== Australia-wide (States) Map ===== -->
      <section class="card">
        <div class="pad">
          <h2>Driving to work vs Working from home (2021)</h2>
          <p class="muted">
            Toggle the metric to colour each state by the proportion of workers who either drove to work or worked from home in 2021. Values are percentages of employed residents.
          </p>

          <div class="map-grid map-grid--notes-left">
            <aside class="side-notes">
              <h3>What the map shows</h3>
              <p>The east posted the strongest shift to home-based work: Sydney ~31% and Melbourne ~26% worked from home in 2021, pulling down their driving shares.</p>
              <p>Further north and west the pattern flips. Queensland and Western Australia remained more car-oriented (Brisbane ~56% driving; Perth ~63%).</p>
              <p>South Australia, Tasmania and the Northern Territory also leaned toward driving, with a more modest take-up of WFH.</p>
              <p>Overall in 2021, the commute picture is split between working at home and private vehicle travel. Differences across states align with industry mix, urban form and how jobs and housing are distributed.</p>
            </aside>

            <div id="ausMap"></div>
          </div>
        </div>
      </section>

      <!-- ===== Why the commute looks like this ===== -->
      <section class="card">
        <div class="pad">
          <h2>Why the commute looks like this</h2>

          <div class="side-notes">
            <h3>Where people work</h3>
            <p>Regional cities have a much higher share of residents who work in the same local area. Townsville (~92%), Ballarat (~85%) and Launceston (~81%) lead the list, with Cairns also high (~67%). Capital cities sit lower—Sydney (~33%), Melbourne (~31%), Brisbane (~28%) and Adelaide (~27%)—while Darwin (~45%) and Hobart (~42%) sit in the middle. Stronger local job–housing match outside the big metros helps explain the map.</p>

            <h3>How long trips are</h3>
            <p>The national commute-time curve peaks at 15–25 minutes (each a little over one-fifth of commuters). After ~35 minutes the shares taper steadily; only about one in seven Australians travel 55+ minutes, and very long trips (60+ minutes) are rare.</p>
          </div>

          <div class="two-grid">
            <div>
              <h3 style="margin:8px 0 6px">Share working locally, by city (2021)</h3>
              <div id="cityLocalWork"></div>
            </div>

            <div>
              <h3 style="margin:8px 0 6px">Commute time distribution — Australia (2021)</h3>
              <div id="nationalCommuteTime"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- ===== Greater Melbourne — Dot map by mode & year ===== -->
      <section class="card">
        <div class="pad">
          <h2>Greater Melbourne — Dot map by mode &amp; year</h2>
          <div class="controls">
            <label>Mode:</label>
            <select id="modeSel"></select>
            <span style="margin-left:8px">Year:</span>
            <button class="btn" data-year="2016" id="y2016">2016</button>
            <button class="btn active" data-year="2021" id="y2021">2021</button>
            <label style="margin-left:12px; display:flex; align-items:center; gap:6px;">
              <input type="checkbox" id="showLabels" />
              Labels
            </label>
          </div>
          <p class="muted">
            Dot size = share (%). Colour shows the percentage band. Use the controls to compare modes and years. Story: Inner Melbourne swung from strong train/tram in 2016 to much higher working-from-home and lower public transport in 2021, while outer suburbs remained more car-reliant.
          </p>
          <div class="banner" id="joinNote">Note: lat/lon were joined from <code>lga_centroids.csv</code> (the data file had no coordinates).</div>
          <p class="muted" style="margin:6px 0 0">Note: finer colour bins are used under 10% (0–5, 6–10), then 10-point steps.</p>
          <div class="legend" id="legend"></div>
        </div>
        <div id="mapBox"></div>
        <div class="pad">
          <p class="muted" style="margin-top:8px">Worked from home rose by a median 36.1 percentage points, with Kensington jumping from 3.7% to 46.4%. Public transport fell by a median 28.7 points, and Kensington dropped from 67.4% to 16.8%. Walking decreased 14.1 points, while “Did not go to work” increased 2.9 points.</p>
        </div>
      </section>

      <!-- ===== Slope Chart Section ===== -->
      <section class="card">
        <div class="pad">
          <h2>Shift in Transportation Modes (2016 → 2021)</h2>
          <p class="muted">Click a mode (legend or line) to highlight it. Others will dim. Double-click anywhere to reset.</p>
          <div class="slope-grid">
            <div id="slopeChart"></div>
            <aside class="side-notes">
              <h3>What stands out</h3>
              <p>Car, as driver remained dominant but fell from ~62% (2016) to ~53% (2021).</p>
              <p>Worked at home rose the most—from ~5% to ~21%—the defining change of the period.</p>
              <p>Public transport contracted sharply: train and bus both roughly halved. Walking, cycling and car-passenger edged down.</p>
              <p>Taken together, Australians moved from shared seats toward home-based work and, when they travelled, private cars.</p>
            </aside>
          </div>
        </div>
      </section>

    </div>
  </div>

  <!-- ===== Australia-wide Vega-Lite Map ===== -->
  <script>
  (async function(){
    const csvURL  = "https://khanhl123.github.io/FIT3179-A2/gccsa_capitals_wfh_drivers_2021.csv";
    const steURL  = "https://khanhl123.github.io/FIT3179-A2/ste_2021.json";

    let featureName = "STE_2021_AUST_GDA2020";
    try {
      const res = await fetch(steURL);
      const topo = await res.json();
      const objects = (topo && topo.objects) ? Object.keys(topo.objects) : [];
      if (objects.includes("STE_2021_AUST_GDA2020")) featureName = "STE_2021_AUST_GDA2020";
      else if (objects.includes("states")) featureName = "states";
      else if (objects.length) featureName = objects[0];
    } catch(e) {}

    const ausSpec = {
      $schema: "https://vega.github.io/schema/vega-lite/v5.json",
      width: "container",
      height: 420,
      projection: { type: "equalEarth", rotate: [-134, 0, 0] },
      params: [
        {
          name: "metricSel",
          value: "driver_pct",
          bind: { input: "radio", name: "Metric: ",
                  options: ["driver_pct","wfh_pct_2021"],
                  labels: ["Drivers (%)","Working from home (%)"] }
        }
      ],
      layer: [
        {
          data: { url: steURL, format: { type: "topojson", feature: featureName } },
          transform: [
            { calculate: "(datum.properties && (datum.properties['STE_NAME_2021'] || datum.properties['STE_NAME21'] || datum.properties['STATE_NAME']))", as: "state_name" },
            { lookup: "state_name",
              from: { data: { url: csvURL }, key: "STE_NAME_2021",
                      fields: ["driver_pct","wfh_pct_2021"] } },
            { calculate: "metricSel === 'driver_pct' ? 'Drivers (%)' : 'WFH (%)'", as: "metric_name" },
            { calculate: "metricSel === 'driver_pct' ? datum.driver_pct : datum.wfh_pct_2021", as: "metric_value" }
          ],
          mark: { type: "geoshape", stroke: "#94a3b8", strokeWidth: 0.8 },
          encoding: {
            color: {
              condition: {
                test: "isValid(datum.metric_value)",
                field: "metric_value", type: "quantitative",
                title: "Proportion (%)",
                scale: { domain: [0, 80], scheme: "blues" },
                legend: { format: ".0f" }
              },
              value: "#e5e7eb"
            },
            tooltip: [
              { field: "state_name", title: "State/Territory" },
              { field: "metric_name", title: "Metric" },
              { field: "metric_value", title: "Proportion (%)", format: ".1f" }
            ]
          }
        },
        {
          data: { url: steURL, format: { type: "topojson", feature: featureName } },
          mark: { type: "geoshape", fill: null, stroke: "#334155", strokeWidth: 0.9 }
        }
      ],
      config: { view: { stroke: null }, axis: { labelFontSize: 12, titleFontSize: 13 } }
    };

    vegaEmbed("#ausMap", ausSpec, {actions:false}).catch(()=>{});
  })();
  </script>

  <!-- ===== Greater Melbourne D3 Map ===== -->
  <script>
  (async function () {
    const topoUrl = "LGA_2021_AUST_GDA2020.json";
    const dataUrl = "B__Wide_comparison__Area___mode__2016_vs_2021_.csv";
    const centUrl = "lga_centroids.csv";

    const MODE_ALIASES = new Map([
      ["taxi/ride-share","Taxi/Rideshare"],["taxi/ride share","Taxi/Rideshare"],
      ["car - as driver","Car driver"],["car- as driver","Car driver"],
      ["car - as passenger","Car passenger"],["walked only","Walk"]
    ]);
    function normName(s){ return String(s||"").toLowerCase().replace(/\s*\([^)]*\)\s*/g," ").replace(/^city of\s+/,"").replace(/[–—-]+/g," ").replace(/\s+/g," ").trim(); }
    function normMode(s){ const raw = normName(s); return MODE_ALIASES.get(raw) || String(s); }
    function toNum(x){ if (x == null) return NaN; const s = String(x).replace(/,/g,"").replace(/%/g,"").trim(); const v = +s; return Number.isFinite(v) ? v : NaN; }
    const endsWithN = a => /\(\s*N\s*\)\s*$/i.test(String(a||"").trim());

    /* Breaks (0–5, 6–10, then 10-pt bins up to 71–80) */
    const thresholds = [5,10,20,30,40,50,60,70];
    /* Keep the sequential scale but avoid strong greens in mid-bins */
    const colors = [
      "#ef4444", "#f59e0b", "#fbbf24", "#60a5fa",
      "#3b82f6", "#6366f1", "#4f46e5", "#334155", "#94a3b8"
    ];
    const colorScale = d3.scaleThreshold().domain(thresholds).range(colors);
    function labelFor(v){
      if (!Number.isFinite(v)) return "No data";
      if (v <= 5)  return "0–5%";
      if (v <= 10) return "6–10%";
      if (v <= 20) return "11–20%";
      if (v <= 30) return "21–30%";
      if (v <= 40) return "31–40%";
      if (v <= 50) return "41–50%";
      if (v <= 60) return "51–60%";
      if (v <= 70) return "61–70%";
      return "71–80%";
    }

    const legend = document.getElementById("legend");
    ["0–5%","6–10%","11–20%","21–30%","31–40%","41–50%","51–60%","61–70%","71–80%"]
      .forEach((lab,i) => {
        const el = document.createElement("div");
        el.innerHTML = `<span class="sw" style="background:${colors[i]}"></span>
                        <span style="font-size:12px;color:#475569">${lab}</span>`;
        legend.appendChild(el);
      });

    const width = document.getElementById("mapBox").clientWidth;
    const height = document.getElementById("mapBox").clientHeight;
    const svg = d3.select("#mapBox").append("svg").attr("viewBox", [0,0,width,height]);
    const gBase = svg.append("g");
    const gDots = svg.append("g");
    const gLabels = svg.append("g");
    const tip = d3.select("body").append("div").attr("class","tooltip").style("opacity",0);

    const [topology, rawDataAll, centroidsAll] = await Promise.all([
      d3.json(topoUrl),
      d3.csv(dataUrl),
      d3.csv(centUrl, d3.autoType)
    ]);

    const rawData0 = rawDataAll.filter(d => !endsWithN(d.Area));
    const EXCLUDE = new Set(["total","not stated","other","other mode","did not go to work"]);
    const centroids = centroidsAll.filter(d => !endsWithN(d.Area));

    const objName = (topology.objects && topology.objects.LGA_2021_AUST_GDA2020)
      ? "LGA_2021_AUST_GDA2020"
      : Object.keys(topology.objects)[0];
    const geo = topojson.feature(topology, topology.objects[objName]);
    let melb = geo;
    const sampleProps = (geo.features[0] && geo.features[0].properties) || {};
    if ("GCC_NAME21" in sampleProps) {
      melb = {type:"FeatureCollection",features: geo.features.filter(f => f.properties.GCC_NAME21 === "Greater Melbourne")};
    }

    const projection = d3.geoMercator().fitSize([width,height], melb);
    const path = d3.geoPath(projection);
    gBase.append("g")
      .selectAll("path").data(melb.features).join("path")
      .attr("d", path).attr("fill", "#eef2ff")
      .attr("stroke", "#94a3b8").attr("stroke-width", 0.6);

    const hasLon = rawData0.length && ("lon" in rawData0[0]);
    const hasLat = rawData0.length && ("lat" in rawData0[0]);

    let data = rawData0.map(d => ({
      Area: d.Area,
      area_norm: normName(d.Area),
      mode: normMode(d.mode ?? d.Mode ?? d.data_label ?? d["Data label"]),
      share_2016: toNum(d.share_2016 ?? d["2016%"] ?? d["2016 %"]),
      share_2021: toNum(d.share_2021 ?? d["2021%"] ?? d["2021 %"]),
      delta_pp: toNum(d.delta_pp ?? (toNum(d["2021%"])-toNum(d["2016%"]))),
      lon: hasLon ? +d.lon : NaN,
      lat: hasLat ? +d.lat : NaN
    })).filter(d => !EXCLUDE.has(normName(d.mode)));

    if (!hasLon || !hasLat) {
      const centByArea = new Map(centroids.map(c => [normName(c.Area), {lon:+c.lon, lat:+c.lat}]));
      data.forEach(d => { const c = centByArea.get(d.area_norm); if (c) { d.lon = c.lon; d.lat = c.lat; } });
      document.getElementById("joinNote").style.display = "block";
    }

    const modes = Array.from(new Set(data.map(d => d.mode))).filter(Boolean).sort((a,b)=>a.localeCompare(b));
    const modeSel = document.getElementById("modeSel");
    modes.forEach(m => modeSel.appendChild(new Option(m, m)));

    const y2016 = document.getElementById("y2016");
    const y2021 = document.getElementById("y2021");
    const showLabels = document.getElementById("showLabels");
    function setYear(y){ y2016.classList.toggle("active", y===2016); y2021.classList.toggle("active", y===2021); render(modeSel.value, y, showLabels.checked); }
    modeSel.addEventListener("change", () => setYear(y2016.classList.contains("active") ? 2016 : 2021));
    y2016.addEventListener("click", () => setYear(2016));
    y2021.addEventListener("click", () => setYear(2021));
    showLabels.addEventListener("change", () => setYear(y2016.classList.contains("active") ? 2016 : 2021));

    function render(mode, year, withLabels){
      const rows = data.filter(d => d.mode === mode);
      const pts = rows.map(d => {
        const value = year === 2016 ? d.share_2016 : d.share_2021;
        const hasValue = Number.isFinite(value);
        const hasCoord = Number.isFinite(d.lon) && Number.isFinite(d.lat);
        const p = hasCoord ? projection([d.lon, d.lat]) : null;
        return { Area: d.Area, x0: p? p[0]:undefined, y0: p? p[1]:undefined, value, hasValue, mode, year };
      }).filter(d => d.x0 !== undefined);

      const vMax = d3.max(pts.filter(d => d.hasValue), d => d.value) || 10;
      const r = d3.scaleSqrt().domain([0, vMax]).range([2, 10]);
      const nodes = pts.map(d => ({ ...d, x: d.x0, y: d.y0 }));
      const sim = d3.forceSimulation(nodes)
        .force("x", d3.forceX(d => d.x0).strength(0.20))
        .force("y", d3.forceY(d => d.y0).strength(0.20))
        .force("collide", d3.forceCollide(d => r(d.hasValue ? d.value : 0.1) + 1.5))
        .stop();
      for (let i = 0; i < 120; i++) sim.tick();

      const circles = gDots.selectAll("circle").data(nodes, d => d.Area + "__" + mode);
      circles.join(
        enter => enter.append("circle")
          .attr("cx", d => d.x0).attr("cy", d => d.y0).attr("r", 0)
          .attr("fill", d => Number.isFinite(d.value) ? colorScale(d.value) : "#cbd5e1")
          .attr("fill-opacity", d => d.hasValue ? 0.85 : 0.9)
          .attr("stroke", "#0f172a").attr("stroke-opacity", d => d.hasValue ? 0.25 : 0.1).attr("stroke-width", 0.8)
          .on("mousemove", (e,d) => {
            const txt = d.hasValue ? `${d.mode} ${d.year}: ${d.value.toFixed(1)}% (${labelFor(d.value)})` : `No data for ${d.mode} ${d.year}`;
            d3.select(".tooltip").style("opacity",1).html(`<strong>${d.Area}</strong><br>${txt}`)
               .style("left",(e.pageX+12)+"px").style("top",(e.pageY-28)+"px");
          })
          .on("mouseleave", () => d3.select(".tooltip").style("opacity",0))
          .transition().duration(400)
          .attr("cx", d => d.x).attr("cy", d => d.y).attr("r", d => r(d.hasValue ? d.value : 0.1)),
        update => update.transition().duration(300)
          .attr("cx", d => d.x).attr("cy", d => d.y)
          .attr("fill", d => Number.isFinite(d.value) ? colorScale(d.value) : "#cbd5e1")
          .attr("r", d => r(d.hasValue ? d.value : 0.1)),
        exit => exit.transition().duration(200).attr("r",0).remove()
      );

      const labels = gLabels.selectAll("text").data(withLabels ? nodes.filter(d => d.hasValue) : [], d => d.Area + "__" + mode);
      labels.join(
        enter => enter.append("text")
          .attr("class","label").attr("x", d => d.x + 10).attr("y", d => d.y + 3)
          .style("opacity", 0).text(d => `${d.value.toFixed(0)}%`)
          .transition().duration(250).style("opacity", 1),
        update => update.transition().duration(250).attr("x", d => d.x + 10).attr("y", d => d.y + 3).text(d => `${d.value.toFixed(0)}%`),
        exit => exit.transition().duration(150).style("opacity",0).remove()
      );
    }
    setYear(2021);
  })();
  </script>

  <!-- ===== Vega-Lite Slope Chart (custom colours; “Car, as driver” = grey) ===== -->
  <script>
    (function(){
      const container = document.getElementById('slopeChart');
      const measured = container.clientWidth || container.getBoundingClientRect().width || 900;
      const w = Math.min(560, Math.max(320, measured));

      const domain = [
        "Worked at home","Car, as driver","Train","Bus","Tram/light rail","Walked only",
        "Bicycle","Car, as passenger","Taxi/ride-share service","Ferry","Motorbike/scooter","Truck"
      ];
      /* Colour-blind–friendly set; no green at all for “Car, as driver” (grey) */
      const range = [
        "#E64B35", /* Worked at home - orange/red */
        "#6B7280", /* Car, as driver - GREY (requested) */
        "#2F70AF", /* Train - blue */
        "#1F9FB5", /* Bus - cyan */
        "#8E6BBE", /* Tram/light rail - purple */
        "#333333", /* Walked only - dark grey */
        "#D7827E", /* Bicycle - muted salmon */
        "#FDB863", /* Car, as passenger - sand */
        "#80B1D3", /* Taxi/ride-share service - steel blue */
        "#C49A6C", /* Ferry - brownish */
        "#A6A6D2", /* Motorbike/scooter - lavender */
        "#9A9A9A"  /* Truck - mid grey */
      ];

      const slopeSpec = {
        "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
        "description": "Slope chart showing change in transport mode proportions (2016–2021)",
        "data": {
          "url": "https://raw.githubusercontent.com/khanhl123/FIT3179-A2/main/proportion_transportation_slopchart.csv",
          "format": {"type": "csv"}
        },
        "transform": [
          {"filter": "indexof(['Total','Not stated','Other','Other Mode','Other mode','Did not go to work'], datum.mode) < 0"},
          {"fold": ["prop_2016_pct","prop_2021_pct"], "as": ["fold_key","Proportion"]},
          {"calculate": "datum.fold_key === 'prop_2016_pct' ? '2016' : '2021'", "as": "Year"},
          {"calculate": "toNumber(datum.Proportion)", "as": "Proportion"}
        ],
        "params": [
          {"name": "pick","select": {"type": "point", "fields": ["mode"], "on": "click", "clear": "dblclick"},"bind": "legend","empty": "all"}
        ],
        "mark": {"type":"line","point":true},
        "encoding": {
          "x": {"field":"Year","type":"ordinal","sort":["2016","2021"],"scale":{"padding":0.1},"axis":{"title":"Year"}},
          "y": {"field":"Proportion","type":"quantitative","scale":{"domain":[0,70]},"axis":{"title":"Proportion (%)","values":[0,10,20,30,40,50,60,70]}},
          "color": {
            "field":"mode","type":"nominal",
            "scale": {"domain": domain, "range": range},
            "legend":{"title":"Mode of Transport"}
          },
          "opacity": {"condition":{"param":"pick","value":1},"value":0.15},
          "size": {"condition":{"param":"pick","value":3},"value":2},
          "tooltip": [
            {"field":"mode","title":"Mode"},
            {"field":"Year","title":"Year"},
            {"field":"Proportion","title":"Proportion (%)","format":".1f"}
          ]
        },
        "width": w,
        "height": 400,
        "config": {"axis":{"labelFontSize":12,"titleFontSize":13},"legend":{"labelFontSize":12,"titleFontSize":13},"line":{"interpolate":"monotone"},"view":{"stroke":null}}
      };

      vegaEmbed('#slopeChart', slopeSpec, { actions:false, renderer:'svg' })
        .catch(()=>{});
    })();
  </script>

  <!-- ===== Two small charts ===== -->
  <script>
  (function(){
    const urlLocal = "https://khanhl123.github.io/FIT3179-A2/work_locally_by_city_2021.csv";
    const urlTime  = "https://khanhl123.github.io/FIT3179-A2/commute_time_distribution_2021.csv";

    function showError(where, err){
      const el = document.querySelector(where === 'local' ? '#cityLocalWork' : '#nationalCommuteTime');
      const warn = document.createElement('div');
      warn.className = 'muted';
      warn.style.marginTop = '8px';
      warn.textContent = 'Could not load data. Check the CSV file path and that the file is public.';
      el.appendChild(warn);
    }

    const localSpec = {
      $schema: "https://vega.github.io/schema/vega-lite/v5.json",
      data: { url: urlLocal, format: { type: "csv" } },
      width: 520,
      height: { step: 26 },
      transform: [{ calculate: "datum.city_type", as: "City type" }],
      layer: [
        {
          mark: { type: "bar", cornerRadiusEnd: 4 },
          encoding: {
            y: { field: "city", type: "nominal", sort: "-x", title: null },
            x: { field: "pct_work_locally", type: "quantitative", title: "Work locally (%)", scale: { domain: [0, 100] } },
            color: {
              field: "City type", type: "nominal",
              scale: { domain: ["Capital","Regional"], range: ["#0ea5e9","#f59e0b"] },
              legend: { title: "City type" }
            },
            tooltip: [
              { field: "city", title: "City" },
              { field: "City type" },
              { field: "pct_work_locally", title: "Work locally (%)", format: ".1f" }
            ]
          }
        },
        { mark: { type: "text", align: "left", baseline: "middle", dx: 4, fontSize: 11, color: "#0f172a" },
          encoding: { y: { field: "city", type: "nominal", sort: "-x" }, x: { field: "pct_work_locally", type: "quantitative" }, text: { field: "pct_work_locally", type: "quantitative", format: ".1f" } }
        }
      ],
      config: { view: { stroke: null }, axis: { labelFontSize: 12, titleFontSize: 13 } }
    };

    const timeSpec = {
      $schema: "https://vega.github.io/schema/vega-lite/v5.json",
      data: { url: urlTime, format: { type: "csv" } },
      width: 520,
      height: 220,
      transform: [
        { calculate: "(datum.time_bin || datum.bin || datum.minutes || datum.Time || datum.category || datum.Category)", as: "BinLabel" },
        { calculate: "parseInt(datum.BinLabel)", as: "BinNum" },
        { calculate: "toNumber(replace((datum.commuters || datum.count || datum.Count || datum.total || datum.Total || ''), ',',''))", as: "Commuters" },
        { filter: "isValid(datum.BinLabel) && isValid(datum.Commuters)" },
        { joinaggregate: [{ op: "sum", field: "Commuters", as: "AllCommuters" }] },
        { calculate: "datum.Commuters / datum.AllCommuters * 100", as: "SharePct" }
      ],
      mark: { type: "line", point: true, interpolate: "monotone" },
      encoding: {
        x: { field: "BinLabel", type: "ordinal", sort: {"field":"BinNum","order":"ascending"}, title: "Commute time (minutes)" },
        y: { field: "SharePct", type: "quantitative", title: "Share of commuters (%)", scale: { domain: [0, 100] } },
        order: { field: "BinNum", type: "quantitative" },
        tooltip: [
          { field: "BinLabel", title: "Time" },
          { field: "SharePct", title: "Share (%)", format: ".1f" },
          { field: "Commuters", title: "Commuters", format: "," }
        ]
      },
      config: { view: { stroke: null }, axis: { labelFontSize: 12, titleFontSize: 13 } }
    };

    vegaEmbed("#cityLocalWork", localSpec, {actions:false}).catch(err => showError('local', err));
    vegaEmbed("#nationalCommuteTime", timeSpec, {actions:false}).catch(err => showError('time', err));
  })();
  </script>

  <!-- ===== Data Sources & References ===== -->
  <footer style="background:#f8fafc; border-top:1px solid #e2e8f0; padding:24px 16px; text-align:center; color:#334155; font-size:14px; line-height:1.6;">
    <p><strong>Data sources:</strong></p>
    <p>
      <a href="https://www.abs.gov.au/Ausstats/Abs@.Nsf/7d12b0f6763c78caca257061001cc588/531cdabf5b2ecff9ca25829400128632!OpenDocument" target="_blank">ABS – Method of Travel to Work, 2016 &amp; 2021</a> •
      <a href="https://www.abs.gov.au/articles/australias-journey-work" target="_blank">ABS – Australia’s Journey to Work</a> •
      <a href="https://www.bitre.gov.au/sites/default/files/is_073.pdf" target="_blank">BITRE – Travel to Work in Australian Cities</a> •
      <a href="https://profile.id.com.au/australia/travel-to-work" target="_blank">profile.id – Travel to Work in Australia</a>
    </p>
    <p>
      Map boundaries: ABS ASGS 2021. Visualisations created with
      <a href="https://vega.github.io/vega-lite/" target="_blank">Vega-Lite</a> and D3.js.
    </p>
    <p>
      Author: <strong>Your Name</strong> • Updated: <strong>21 Oct 2025</strong>
    </p>
  </footer>
</body>
</html>
