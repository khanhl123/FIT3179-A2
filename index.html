<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>How Australians got to work?</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{margin:0;background:#f7f9fc;color:#0f172a;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    header{padding:28px 20px;text-align:center;}
    h1{margin:0;font-size:clamp(28px,3.5vw,44px);letter-spacing:-0.02em}
    .subtitle{margin-top:6px;color:#64748b;font-size:14px}
    .wrap{max-width:1200px;margin:0 auto;padding:0 16px 40px}
    .grid{display:grid;grid-template-columns:1fr;gap:20px}
    .card{background:#fff;border:1px solid #e5e7eb;border-radius:16px;box-shadow:0 4px 18px rgba(15,23,42,.06)}
    .pad{padding:18px}
    .card h2{font-size:20px;margin:0 0 12px}
    #mapBox{height:620px; position:relative;}
    .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:6px 0 10px}
    select,button,label{font:inherit}
    .btn{padding:6px 10px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;cursor:pointer}
    .btn.active{background:#0f172a;color:#fff;border-color:#0f172a}
    .muted{color:#64748b;font-size:12px}
    .tooltip{position:absolute;pointer-events:none;background:#111827;color:#fff;padding:8px 10px;border-radius:10px;font-size:12px;box-shadow:0 6px 18px rgba(0,0,0,.2)}
    .banner{margin-top:8px;color:#b45309;background:#fff7ed;border:1px solid #fde68a;padding:8px 10px;border-radius:8px;display:none}
    .legend{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
    .sw{width:14px;height:14px;border-radius:3px;border:1px solid #e2e8f0;display:inline-block}
    svg{display:block;width:100%;height:100%}
    .label{font-size:10px;fill:#111827;paint-order:stroke;stroke:#fff;stroke-width:3px;stroke-linejoin:round}
    @media (max-width: 960px){ .grid{grid-template-columns:1fr} #mapBox{height:520px} }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
</head>
<body>
  <header>
    <h1>How Australians got to work?</h1>
    <div class="subtitle">Dot map of mode share by LGA (2016 vs 2021) over a Greater Melbourne outline.</div>
  </header>

  <div class="wrap">
    <div class="grid">
      <section class="card">
        <div class="pad">
          <h2>Greater Melbourne — Dot map by mode & year</h2>
          <div class="controls">
            <label>Mode:</label>
            <select id="modeSel"></select>
            <span style="margin-left:8px">Year:</span>
            <button class="btn" data-year="2016" id="y2016">2016</button>
            <button class="btn active" data-year="2021" id="y2021">2021</button>
            <label style="margin-left:12px; display:flex; align-items:center; gap:6px;">
              <input type="checkbox" id="showLabels" />
              Labels
            </label>
          </div>
          <div class="muted">Dot size = share (%). Colour = binned percentage. Grey = no value for that Area+mode+year.</div>
          <div class="banner" id="joinNote">Note: lat/lon were joined from <code>lga_centroids.csv</code> (the data file had no coordinates).</div>
          <div class="legend" id="legend"></div>
        </div>

        <div id="mapBox"></div>

        <div class="pad">
          <p class="muted" style="margin-top:8px">
            This interactive map shows, for each Greater Melbourne area, the proportion of employed residents using the selected travel mode—including working from home—in 2016 and 2021. Dot size represents local mode share and colour reflects binned percentage ranges.
          </p>
        </div>
      </section>
    </div>
  </div>

  <script>
  (async function () {
    // ===== File names (same folder as index.html) =====
    const topoUrl = "LGA_2021_AUST_GDA2020.json"; // << here: your new LGA TopoJSON
    const dataUrl = "B__Wide_comparison__Area___mode__2016_vs_2021_.csv";
    const centUrl = "lga_centroids.csv";

    // Helpers
    const MODE_ALIASES = new Map([
      ["taxi/ride-share","Taxi/Rideshare"],["taxi/ride share","Taxi/Rideshare"],
      ["car - as driver","Car driver"],["car- as driver","Car driver"],
      ["car - as passenger","Car passenger"],["walked only","Walk"]
    ]);
    function normName(s){
      return String(s||"")
        .toLowerCase()
        .replace(/\s*\([^)]*\)\s*/g," ")
        .replace(/^city of\s+/,"")
        .replace(/[–—-]+/g," ")
        .replace(/\s+/g," ").trim();
    }
    function normMode(s){
      const raw = normName(s);
      return MODE_ALIASES.get(raw) || String(s);
    }
    function toNum(x){
      if (x == null) return NaN;
      const s = String(x).replace(/,/g,"").replace(/%/g,"").trim();
      const v = +s;
      return Number.isFinite(v) ? v : NaN;
    }
    const endsWithN = a => /\(\s*N\s*\)\s*$/i.test(String(a||"").trim());

    // ----- Binned colour scale (fixed threshold binning) -----
    // (Fix: 8 thresholds -> 9 bins; your legend lists 9 bins)
    const thresholds = [20,30,40,50,60,70,80,90];
    const colors = ["#ef4444","#3b82f6","#22c55e","#a855f7","#f59e0b","#06b6d4","#eab308","#ec4899","#0f172a"];
    const colorScale = d3.scaleThreshold().domain(thresholds).range(colors);
    function labelFor(v){
      if (!Number.isFinite(v)) return "No data";
      if (v <= 20) return "0–20%";
      if (v <= 30) return "21–30%";
      if (v <= 40) return "31–40%";
      if (v <= 50) return "41–50%";
      if (v <= 60) return "51–60%";
      if (v <= 70) return "61–70%";
      if (v <= 80) return "71–80%";
      if (v <= 90) return "81–90%";
      return "91–100%";
    }
    // Legend UI
    const legend = document.getElementById("legend");
    ["0–20%","21–30%","31–40%","41–50%","51–60%","61–70%","71–80%","81–90%","91–100%"]
      .forEach((lab,i) => {
        const el = document.createElement("div");
        el.innerHTML = `<span class="sw" style="background:${colors[i]}"></span>
                        <span style="font-size:12px;color:#475569">${lab}</span>`;
        legend.appendChild(el);
      });

    // SVG
    const width = document.getElementById("mapBox").clientWidth;
    const height = document.getElementById("mapBox").clientHeight;
    const svg = d3.select("#mapBox").append("svg").attr("viewBox", [0,0,width,height]);
    const gBase = svg.append("g");
    const gDots = svg.append("g");
    const gLabels = svg.append("g");
    const tip = d3.select("body").append("div").attr("class","tooltip").style("opacity",0);

    // Load files
    const [topology, rawDataAll, centroidsAll] = await Promise.all([
      d3.json(topoUrl),
      d3.csv(dataUrl),
      d3.csv(centUrl, d3.autoType)
    ]);

    // Filter out areas ending with “(N)”
    const rawData = rawDataAll.filter(d => !endsWithN(d.Area));
    const centroids = centroidsAll.filter(d => !endsWithN(d.Area));

    // ----- LGA polygons (match your data geography) -----
    // Try to use the expected object name; fall back to the first object if needed.
    const objName = (topology.objects && topology.objects.LGA_2021_AUST_GDA2020)
      ? "LGA_2021_AUST_GDA2020"                                     // << here: TopoJSON object name
      : Object.keys(topology.objects)[0];

    const geo = topojson.feature(topology, topology.objects[objName]);

    // If your TopoJSON is already clipped to Greater Melbourne (31 LGAs), use all features.
    // If it includes GCC_NAME21, we can filter to "Greater Melbourne".
    let melb = geo;
    const sampleProps = (geo.features[0] && geo.features[0].properties) || {};
    if ("GCC_NAME21" in sampleProps) {
      melb = {
        type:"FeatureCollection",
        features: geo.features.filter(f => f.properties.GCC_NAME21 === "Greater Melbourne")
      };
    }

    const projection = d3.geoMercator().fitSize([width,height], melb);
    const path = d3.geoPath(projection);

    gBase.append("g")
      .selectAll("path").data(melb.features).join("path")
      .attr("d", path)
      .attr("fill", "#eef2ff")
      .attr("stroke", "#94a3b8")
      .attr("stroke-width", 0.6);

    // Does data include lon/lat?
    const hasLon = rawData.length && ("lon" in rawData[0]);
    const hasLat = rawData.length && ("lat" in rawData[0]);

    // Tidy table
    let data = rawData.map(d => ({
      Area: d.Area,
      area_norm: normName(d.Area),
      mode: normMode(d.mode ?? d.Mode ?? d.data_label ?? d["Data label"]),
      share_2016: toNum(d.share_2016 ?? d["2016%"] ?? d["2016 %"]),
      share_2021: toNum(d.share_2021 ?? d["2021%"] ?? d["2021 %"]),
      delta_pp: toNum(d.delta_pp ?? (toNum(d["2021%"])-toNum(d["2016%"]))),
      lon: hasLon ? +d.lon : NaN,
      lat: hasLat ? +d.lat : NaN
    }));

    // Join lon/lat if missing
    if (!hasLon || !hasLat) {
      const centByArea = new Map(centroids.map(c => [normName(c.Area), {lon:+c.lon, lat:+c.lat}]));
      data.forEach(d => {
        const c = centByArea.get(d.area_norm);
        if (c) { d.lon = c.lon; d.lat = c.lat; }
      });
      document.getElementById("joinNote").style.display = "block";
    }

    // Mode list
    const modes = Array.from(new Set(data.map(d => d.mode))).filter(Boolean).sort((a,b)=>a.localeCompare(b));
    const modeSel = document.getElementById("modeSel");
    modes.forEach(m => modeSel.appendChild(new Option(m, m)));

    // Controls
    const y2016 = document.getElementById("y2016");
    const y2021 = document.getElementById("y2021");
    const showLabels = document.getElementById("showLabels");
    function setYear(y){ y2016.classList.toggle("active", y===2016); y2021.classList.toggle("active", y===2021); render(modeSel.value, y, showLabels.checked); }
    modeSel.addEventListener("change", () => setYear(y2016.classList.contains("active") ? 2016 : 2021));
    y2016.addEventListener("click", () => setYear(2016));
    y2021.addEventListener("click", () => setYear(2021));
    showLabels.addEventListener("change", () => setYear(y2016.classList.contains("active") ? 2016 : 2021));

    // Render with force-collision + threshold colours + optional labels
    function render(mode, year, withLabels){
      const rows = data.filter(d => d.mode === mode);

      const pts = rows.map(d => {
        const value = year === 2016 ? d.share_2016 : d.share_2021;
        const hasValue = Number.isFinite(value);
        const hasCoord = Number.isFinite(d.lon) && Number.isFinite(d.lat);
        const p = hasCoord ? projection([d.lon, d.lat]) : null;
        return { Area: d.Area, x0: p? p[0]:undefined, y0: p? p[1]:undefined, value, hasValue, mode, year };
      }).filter(d => d.x0 !== undefined);

      const vMax = d3.max(pts.filter(d => d.hasValue), d => d.value) || 10;
      const r = d3.scaleSqrt().domain([0, vMax]).range([2, 10]);

      // force separation
      const nodes = pts.map(d => ({ ...d, x: d.x0, y: d.y0 }));
      const sim = d3.forceSimulation(nodes)
        .force("x", d3.forceX(d => d.x0).strength(0.20))
        .force("y", d3.forceY(d => d.y0).strength(0.20))
        .force("collide", d3.forceCollide(d => r(d.hasValue ? d.value : 0.1) + 1.5))
        .stop();
      for (let i = 0; i < 120; i++) sim.tick();

      // circles
      const circles = gDots.selectAll("circle").data(nodes, d => d.Area + "__" + mode);
      circles.join(
        enter => enter.append("circle")
          .attr("cx", d => d.x0).attr("cy", d => d.y0).attr("r", 0)
          .attr("fill", d => Number.isFinite(d.value) ? colorScale(d.value) : "#cbd5e1")
          .attr("fill-opacity", d => d.hasValue ? 0.85 : 0.9)
          .attr("stroke", "#0f172a").attr("stroke-opacity", d => d.hasValue ? 0.25 : 0.1).attr("stroke-width", 0.8)
          .on("mousemove", (e,d) => {
            const txt = d.hasValue ? `${d.mode} ${d.year}: ${d.value.toFixed(1)}% (${labelFor(d.value)})` : `No data for ${d.mode} ${d.year}`;
            tip.style("opacity",1).html(`<strong>${d.Area}</strong><br>${txt}`)
               .style("left",(e.pageX+12)+"px").style("top",(e.pageY-28)+"px");
          })
          .on("mouseleave", () => tip.style("opacity",0))
          .transition().duration(400)
          .attr("cx", d => d.x).attr("cy", d => d.y).attr("r", d => r(d.hasValue ? d.value : 0.1)),
        update => update.transition().duration(300)
          .attr("cx", d => d.x).attr("cy", d => d.y)
          .attr("fill", d => Number.isFinite(d.value) ? colorScale(d.value) : "#cbd5e1")
          .attr("r", d => r(d.hasValue ? d.value : 0.1)),
        exit => exit.transition().duration(200).attr("r",0).remove()
      );

      // labels
      const labels = gLabels.selectAll("text").data(withLabels ? nodes.filter(d => d.hasValue) : [], d => d.Area + "__" + mode);
      labels.join(
        enter => enter.append("text")
          .attr("class","label").attr("x", d => d.x + 10).attr("y", d => d.y + 3)
          .style("opacity", 0).text(d => `${d.value.toFixed(0)}%`)
          .transition().duration(250).style("opacity", 1),
        update => update.transition().duration(250).attr("x", d => d.x + 10).attr("y", d => d.y + 3).text(d => `${d.value.toFixed(0)}%`),
        exit => exit.transition().duration(150).style("opacity",0).remove()
      );

      const missing = nodes.filter(d => !d.hasValue).length;
      console.log(`Mode=${mode} Year=${year}: ${nodes.length - missing} dots with data; ${missing} grey.`);
    }

    // initial
    setYear(2021);
  })();
  </script>
</body>
</html>
