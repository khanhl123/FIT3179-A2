<!-- ===== Greater Melbourne D3 Map ===== -->
<script>
(async function () {
  const topoUrl = "LGA_2021_AUST_GDA2020.json";
  const dataUrl = "B__Wide_comparison__Area___mode__2016_vs_2021_.csv";
  const centUrl = "lga_centroids.csv";

  const MODE_ALIASES = new Map([
    ["taxi/ride-share","Taxi/Rideshare"],["taxi/ride share","Taxi/Rideshare"],
    ["car - as driver","Car driver"],["car- as driver","Car driver"],
    ["car - as passenger","Car passenger"],["walked only","Walk"]
  ]);
  const EXCLUDE = new Set(["Not stated","Other","Total","Did not go to work"]);

  function normName(s){ return String(s||"").toLowerCase()
    .replace(/\s*\([^)]*\)\s*/g," ")
    .replace(/^city of\s+/,"")
    .replace(/[–—-]+/g," ")
    .replace(/\s+/g," ")
    .trim(); }
  function normMode(s){ const raw = normName(s); return MODE_ALIASES.get(raw) || String(s); }
  function toNum(x){ if (x == null) return NaN; const s = String(x).replace(/,/g,"").replace(/%/g,"").trim(); const v = +s; return Number.isFinite(v) ? v : NaN; }
  const endsWithN = a => /\(\s*N\s*\)\s*$/i.test(String(a||"").trim());

  /* === NEW BINS & COLOURS ===
     Bands: 0–10, 11–20, 21–30, 31–40, 41–50, 51–60, 61–70, 71–80  */
  const thresholds = [10,20,30,40,50,60,70];      // 7 thresholds -> 8 bins
  const colors = ["#ef4444","#3b82f6","#22c55e","#a855f7","#f59e0b","#06b6d4","#eab308","#6366f1"]; // removed pink/black
  const colorScale = d3.scaleThreshold().domain(thresholds).range(colors);

  function labelFor(v){
    if (!Number.isFinite(v)) return "No data";
    if (v <= 10) return "0–10%";
    if (v <= 20) return "11–20%";
    if (v <= 30) return "21–30%";
    if (v <= 40) return "31–40%";
    if (v <= 50) return "41–50%";
    if (v <= 60) return "51–60%";
    if (v <= 70) return "61–70%";
    return "71–80%"; // clamp anything >70 into the last band
  }

  // Build legend (8 swatches)
  const legend = document.getElementById("legend");
  legend.innerHTML = "";
  ["0–10%","11–20%","21–30%","31–40%","41–50%","51–60%","61–70%","71–80%"]
    .forEach((lab,i) => {
      const el = document.createElement("div");
      el.innerHTML = `<span class="sw" style="background:${colors[i]}"></span>
                      <span style="font-size:12px;color:#475569">${lab}</span>`;
      legend.appendChild(el);
    });

  const width = document.getElementById("mapBox").clientWidth;
  const height = document.getElementById("mapBox").clientHeight;
  const svg = d3.select("#mapBox").append("svg").attr("viewBox", [0,0,width,height]);
  const gBase = svg.append("g");
  const gDots = svg.append("g");
  const gLabels = svg.append("g");
  const tip = d3.select("body").append("div").attr("class","tooltip").style("opacity",0);

  const [topology, rawDataAll, centroidsAll] = await Promise.all([
    d3.json(topoUrl),
    d3.csv(dataUrl),
    d3.csv(centUrl, d3.autoType)
  ]);

  const rawData = rawDataAll.filter(d => !endsWithN(d.Area));
  const centroids = centroidsAll.filter(d => !endsWithN(d.Area));

  const objName = (topology.objects && topology.objects.LGA_2021_AUST_GDA2020)
    ? "LGA_2021_AUST_GDA2020"
    : Object.keys(topology.objects)[0];
  const geo = topojson.feature(topology, topology.objects[objName]);
  let melb = geo;
  const sampleProps = (geo.features[0] && geo.features[0].properties) || {};
  if ("GCC_NAME21" in sampleProps) {
    melb = {type:"FeatureCollection",features: geo.features.filter(f => f.properties.GCC_NAME21 === "Greater Melbourne")};
  }

  const projection = d3.geoMercator().fitSize([width,height], melb);
  const path = d3.geoPath(projection);
  gBase.append("g")
    .selectAll("path").data(melb.features).join("path")
    .attr("d", path).attr("fill", "#eef2ff")
    .attr("stroke", "#94a3b8").attr("stroke-width", 0.6);

  const hasLon = rawData.length && ("lon" in rawData[0]);
  const hasLat = rawData.length && ("lat" in rawData[0]);

  // Parse rows
  let data = rawData.map(d => ({
    Area: d.Area,
    area_norm: normName(d.Area),
    mode: normMode(d.mode ?? d.Mode ?? d.data_label ?? d["Data label"]),
    share_2016: toNum(d.share_2016 ?? d["2016%"] ?? d["2016 %"]),
    share_2021: toNum(d.share_2021 ?? d["2021%"] ?? d["2021 %"]),
    delta_pp: toNum(d.delta_pp ?? (toNum(d["2021%"])-toNum(d["2016%"]))),
    lon: hasLon ? +d.lon : NaN,
    lat: hasLat ? +d.lat : NaN
  }));

  // === EXCLUDE unwanted modes from both the dataset and the dropdown ===
  data = data.filter(d => !EXCLUDE.has(d.mode));

  if (!hasLon || !hasLat) {
    const centByArea = new Map(centroids.map(c => [normName(c.Area), {lon:+c.lon, lat:+c.lat}]));
    data.forEach(d => { const c = centByArea.get(d.area_norm); if (c) { d.lon = c.lon; d.lat = c.lat; } });
    document.getElementById("joinNote").style.display = "block";
  }

  // Build the mode list (without excluded items)
  const modes = Array.from(new Set(data.map(d => d.mode)))
    .filter(Boolean)
    .sort((a,b)=>a.localeCompare(b));
  const modeSel = document.getElementById("modeSel");
  modeSel.innerHTML = "";
  modes.forEach(m => modeSel.appendChild(new Option(m, m)));
  if (modes.includes("Bicycle")) modeSel.value = "Bicycle";

  const y2016 = document.getElementById("y2016");
  const y2021 = document.getElementById("y2021");
  const showLabels = document.getElementById("showLabels");
  function setYear(y){ y2016.classList.toggle("active", y===2016); y2021.classList.toggle("active", y===2021); render(modeSel.value, y, showLabels.checked); }
  modeSel.addEventListener("change", () => setYear(y2016.classList.contains("active") ? 2016 : 2021));
  y2016.addEventListener("click", () => setYear(2016));
  y2021.addEventListener("click", () => setYear(2021));
  showLabels.addEventListener("change", () => setYear(y2016.classList.contains("active") ? 2016 : 2021));

  function render(mode, year, withLabels){
    const rows = data.filter(d => d.mode === mode);
    const pts = rows.map(d => {
      const value = year === 2016 ? d.share_2016 : d.share_2021;
      const hasValue = Number.isFinite(value);
      const hasCoord = Number.isFinite(d.lon) && Number.isFinite(d.lat);
      const p = hasCoord ? projection([d.lon, d.lat]) : null;
      return { Area: d.Area, x0: p? p[0]:undefined, y0: p? p[1]:undefined, value, hasValue, mode, year };
    }).filter(d => d.x0 !== undefined);

    const vMax = d3.max(pts.filter(d => d.hasValue), d => d.value) || 10;
    const r = d3.scaleSqrt().domain([0, vMax]).range([2, 10]);
    const nodes = pts.map(d => ({ ...d, x: d.x0, y: d.y0 }));
    const sim = d3.forceSimulation(nodes)
      .force("x", d3.forceX(d => d.x0).strength(0.20))
      .force("y", d3.forceY(d => d.y0).strength(0.20))
      .force("collide", d3.forceCollide(d => r(d.hasValue ? d.value : 0.1) + 1.5))
      .stop();
    for (let i = 0; i < 120; i++) sim.tick();

    const circles = gDots.selectAll("circle").data(nodes, d => d.Area + "__" + mode);
    circles.join(
      enter => enter.append("circle")
        .attr("cx", d => d.x0).attr("cy", d => d.y0).attr("r", 0)
        .attr("fill", d => Number.isFinite(d.value) ? colorScale(d.value) : "#cbd5e1")
        .attr("fill-opacity", d => d.hasValue ? 0.85 : 0.9)
        .attr("stroke", "#0f172a").attr("stroke-opacity", d => d.hasValue ? 0.25 : 0.1).attr("stroke-width", 0.8)
        .on("mousemove", (e,d) => {
          const txt = d.hasValue ? `${d.mode} ${d.year}: ${d.value.toFixed(1)}% (${labelFor(d.value)})` : `No data for ${d.mode} ${d.year}`;
          d3.select(".tooltip").style("opacity",1).html(`<strong>${d.Area}</strong><br>${txt}`)
             .style("left",(e.pageX+12)+"px").style("top",(e.pageY-28)+"px");
        })
        .on("mouseleave", () => d3.select(".tooltip").style("opacity",0))
        .transition().duration(400)
        .attr("cx", d => d.x).attr("cy", d => d.y).attr("r", d => r(d.hasValue ? d.value : 0.1)),
      update => update.transition().duration(300)
        .attr("cx", d => d.x).attr("cy", d => d.y)
        .attr("fill", d => Number.isFinite(d.value) ? colorScale(d.value) : "#cbd5e1")
        .attr("r", d => r(d.hasValue ? d.value : 0.1)),
      exit => exit.transition().duration(200).attr("r",0).remove()
    );

    const labels = gLabels.selectAll("text").data(withLabels ? nodes.filter(d => d.hasValue) : [], d => d.Area + "__" + mode);
    labels.join(
      enter => enter.append("text")
        .attr("class","label").attr("x", d => d.x + 10).attr("y", d => d.y + 3)
        .style("opacity", 0).text(d => `${d.value.toFixed(0)}%`)
        .transition().duration(250).style("opacity", 1),
      update => update.transition().duration(250).attr("x", d => d.x + 10).attr("y", d => d.y + 3).text(d => `${d.value.toFixed(0)}%`),
      exit => exit.transition().duration(150).style("opacity",0).remove()
    );
  }
  setYear(2021);
})();
</script>
